// This file is auto-generated by @hey-api/openapi-ts

/**
 * Schema for telling task which bundle to run with.
 */
export type BundleInfo = {
    name: string;
    version?: (string | null);
};

/**
 * Job that is to be executed on the edge worker.
 */
export type EdgeJobFetched = {
    /**
     * Identifier of the DAG to which the task belongs.
     */
    dag_id: string;
    /**
     * Task name in the DAG.
     */
    task_id: string;
    /**
     * Run ID of the DAG execution.
     */
    run_id: string;
    /**
     * For dynamically mapped tasks the mapping number, -1 if the task is not mapped.
     */
    map_index: number;
    /**
     * The number of attempt to execute this task.
     */
    try_number: number;
    /**
     * Command line to use to execute the job in Airflow
     */
    command: ExecuteTask;
    /**
     * Number of concurrency slots the job requires.
     */
    concurrency_slots: number;
};

/**
 * Status of a Edge Worker instance.
 */
export type EdgeWorkerState = 'starting' | 'running' | 'idle' | 'shutdown request' | 'terminating' | 'offline' | 'unknown' | 'maintenance request' | 'maintenance pending' | 'maintenance mode' | 'maintenance exit' | 'offline maintenance';

/**
 * Execute the given Task.
 */
export type ExecuteTask = {
    token: string;
    dag_rel_path: string;
    bundle_info: BundleInfo;
    log_path: (string | null);
    ti: TaskInstance;
    sentry_integration?: string;
    type?: "ExecuteTask";
};

/**
 * HTTPException Model used for error response.
 */
export type HTTPExceptionResponse = {
    detail: (string | {
    [key: string]: unknown;
});
};

export type HTTPValidationError = {
    detail?: Array<ValidationError>;
};

/**
 * Details of the job sent to the scheduler.
 */
export type Job = {
    /**
     * Identifier of the DAG to which the task belongs.
     */
    dag_id: string;
    /**
     * Task name in the DAG.
     */
    task_id: string;
    /**
     * Run ID of the DAG execution.
     */
    run_id: string;
    /**
     * For dynamically mapped tasks the mapping number, -1 if the task is not mapped.
     */
    map_index: number;
    /**
     * The number of attempt to execute this task.
     */
    try_number: number;
    /**
     * State of the job from the view of the executor.
     */
    state: TaskInstanceState;
    /**
     * Queue for which the task is scheduled/running.
     */
    queue: string;
    /**
     * When the job was queued.
     */
    queued_dttm?: (string | null);
    /**
     * The worker processing the job during execution.
     */
    edge_worker?: (string | null);
    /**
     * Last heartbeat of the job.
     */
    last_update?: (string | null);
};

/**
 * Job Collection serializer.
 */
export type JobCollectionResponse = {
    jobs: Array<Job>;
    total_entries: number;
};

/**
 * Request body for maintenance operations.
 */
export type MaintenanceRequest = {
    /**
     * Comment describing the maintenance reason.
     */
    maintenance_comment: string;
};

/**
 * Incremental new log content from worker.
 */
export type PushLogsBody = {
    /**
     * Time of the log chunk at point of sending.
     */
    log_chunk_time: string;
    /**
     * Log chunk data as incremental log text.
     */
    log_chunk_data: string;
};

/**
 * Schema for TaskInstance with minimal required fields needed for Executors and Task SDK.
 */
export type TaskInstance = {
    id: string;
    dag_version_id: string;
    task_id: string;
    dag_id: string;
    run_id: string;
    try_number: number;
    map_index?: number;
    pool_slots: number;
    queue: string;
    priority_weight: number;
    parent_context_carrier?: ({
    [key: string]: unknown;
} | null);
    context_carrier?: ({
    [key: string]: unknown;
} | null);
};

/**
 * All possible states that a Task Instance can be in.
 *
 * Note that None is also allowed, so always use this in a type hint with Optional.
 */
export type TaskInstanceState = 'removed' | 'scheduled' | 'queued' | 'running' | 'success' | 'restarting' | 'failed' | 'up_for_retry' | 'up_for_reschedule' | 'upstream_failed' | 'skipped' | 'deferred';

export type ValidationError = {
    loc: Array<(string | number)>;
    msg: string;
    type: string;
    input?: unknown;
    ctx?: {
        [key: string]: unknown;
    };
};

/**
 * Details of the worker state sent to the scheduler.
 */
export type Worker = {
    /**
     * List of queues the worker is pulling jobs from. If not provided, worker pulls from all queues.
     */
    queues?: (Array<(string)> | null);
    /**
     * State of the worker from the view of the worker.
     */
    state: EdgeWorkerState;
    /**
     * Number of active jobs the worker is running.
     */
    jobs_active?: number;
    /**
     * System information of the worker.
     */
    sysinfo: {
        [key: string]: (string | number);
    };
    /**
     * Comments about the maintenance state of the worker.
     */
    maintenance_comments?: (string | null);
    /**
     * Name of the worker.
     */
    worker_name: string;
    /**
     * When the worker was first online.
     */
    first_online?: (string | null);
    /**
     * When the worker last sent a heartbeat.
     */
    last_heartbeat?: (string | null);
};

/**
 * Worker Collection serializer.
 */
export type WorkerCollectionResponse = {
    workers: Array<Worker>;
    total_entries: number;
};

/**
 * Changed queues for the worker.
 */
export type WorkerQueueUpdateBody = {
    /**
     * Additional queues to be added to worker.
     */
    new_queues: (Array<(string)> | null);
    /**
     * Queues to remove from worker.
     */
    remove_queues: (Array<(string)> | null);
};

/**
 * Queues that a worker supports to run jobs on.
 */
export type WorkerQueuesBody = {
    /**
     * List of queues the worker is pulling jobs from. If not provided, worker pulls from all queues.
     */
    queues?: (Array<(string)> | null);
    /**
     * Number of free concurrency slots on the worker.
     */
    free_concurrency: number;
};

/**
 * The return class for the worker registration.
 */
export type WorkerRegistrationReturn = {
    /**
     * Time of the last update of the worker.
     */
    last_update: string;
};

/**
 * The return class for the worker set state.
 */
export type WorkerSetStateReturn = {
    /**
     * State of the worker from the view of the server.
     */
    state: EdgeWorkerState;
    /**
     * List of queues the worker is pulling jobs from. If not provided, worker pulls from all queues.
     */
    queues: (Array<(string)> | null);
    /**
     * Comments about the maintenance state of the worker.
     */
    maintenance_comments?: (string | null);
};

/**
 * Details of the worker state sent to the scheduler.
 */
export type WorkerStateBody = {
    /**
     * List of queues the worker is pulling jobs from. If not provided, worker pulls from all queues.
     */
    queues?: (Array<(string)> | null);
    /**
     * State of the worker from the view of the worker.
     */
    state: EdgeWorkerState;
    /**
     * Number of active jobs the worker is running.
     */
    jobs_active?: number;
    /**
     * System information of the worker.
     */
    sysinfo: {
        [key: string]: (string | number);
    };
    /**
     * Comments about the maintenance state of the worker.
     */
    maintenance_comments?: (string | null);
};

export type FetchData = {
    body: WorkerQueuesBody;
    headers: {
        /**
         * JWT Authorization Token
         */
        authorization: string;
    };
    path: {
        worker_name: string;
    };
};

export type FetchResponse = ((EdgeJobFetched | null));

export type FetchError = (HTTPExceptionResponse | HTTPValidationError);

export type StateData = {
    headers: {
        /**
         * JWT Authorization Token
         */
        authorization: string;
    };
    path: {
        /**
         * Identifier of the DAG to which the task belongs.
         */
        dag_id: string;
        /**
         * For dynamically mapped tasks the mapping number, -1 if the task is not mapped.
         */
        map_index: number;
        /**
         * Run ID of the DAG execution.
         */
        run_id: string;
        /**
         * State of the assigned task under execution.
         */
        state: TaskInstanceState;
        /**
         * Task name in the DAG.
         */
        task_id: string;
        /**
         * The number of attempt to execute this task.
         */
        try_number: number;
    };
};

export type StateResponse = (unknown);

export type StateError = (HTTPExceptionResponse | HTTPValidationError);

export type LogfilePathData = {
    headers: {
        /**
         * JWT Authorization Token
         */
        authorization: string;
    };
    path: {
        /**
         * Identifier of the DAG to which the task belongs.
         */
        dag_id: string;
        /**
         * For dynamically mapped tasks the mapping number, -1 if the task is not mapped.
         */
        map_index: number;
        /**
         * Run ID of the DAG execution.
         */
        run_id: string;
        /**
         * Task name in the DAG.
         */
        task_id: string;
        /**
         * The number of attempt to execute this task.
         */
        try_number: number;
    };
};

export type LogfilePathResponse = (string);

export type LogfilePathError = (HTTPExceptionResponse | HTTPValidationError);

export type PushLogsData = {
    body: PushLogsBody;
    headers: {
        /**
         * JWT Authorization Token
         */
        authorization: string;
    };
    path: {
        /**
         * Identifier of the DAG to which the task belongs.
         */
        dag_id: string;
        /**
         * For dynamically mapped tasks the mapping number, -1 if the task is not mapped.
         */
        map_index: number;
        /**
         * Run ID of the DAG execution.
         */
        run_id: string;
        /**
         * Task name in the DAG.
         */
        task_id: string;
        /**
         * The number of attempt to execute this task.
         */
        try_number: number;
    };
};

export type PushLogsResponse = (unknown);

export type PushLogsError = (HTTPExceptionResponse | HTTPValidationError);

export type RegisterData = {
    body: WorkerStateBody;
    headers: {
        /**
         * JWT Authorization Token
         */
        authorization: string;
    };
    path: {
        /**
         * Hostname or instance name of the worker
         */
        worker_name: string;
    };
};

export type RegisterResponse = (WorkerRegistrationReturn);

export type RegisterError = (HTTPExceptionResponse | HTTPValidationError);

export type SetStateData = {
    body: WorkerStateBody;
    headers: {
        /**
         * JWT Authorization Token
         */
        authorization: string;
    };
    path: {
        /**
         * Hostname or instance name of the worker
         */
        worker_name: string;
    };
};

export type SetStateResponse = (WorkerSetStateReturn);

export type SetStateError = (HTTPExceptionResponse | HTTPValidationError);

export type UpdateQueuesData = {
    body: WorkerQueueUpdateBody;
    headers: {
        /**
         * JWT Authorization Token
         */
        authorization: string;
    };
    path: {
        /**
         * Hostname or instance name of the worker
         */
        worker_name: string;
    };
};

export type UpdateQueuesResponse = (unknown);

export type UpdateQueuesError = (HTTPExceptionResponse | HTTPValidationError);

export type HealthResponse = ({
    [key: string]: (string);
});

export type HealthError = unknown;

export type WorkerData = {
    query?: {
        queue_name_pattern?: (string | null);
        state?: (Array<EdgeWorkerState> | null);
        worker_name_pattern?: (string | null);
    };
};

export type WorkerResponse = (WorkerCollectionResponse);

export type WorkerError = (HTTPValidationError);

export type JobsData = {
    query?: {
        dag_id_pattern?: (string | null);
        queue_pattern?: (string | null);
        run_id_pattern?: (string | null);
        state?: (Array<TaskInstanceState> | null);
        task_id_pattern?: (string | null);
        worker_name_pattern?: (string | null);
    };
};

export type JobsResponse = (JobCollectionResponse);

export type JobsError = (HTTPValidationError);

export type RequestWorkerMaintenanceData = {
    body: MaintenanceRequest;
    path: {
        worker_name: string;
    };
};

export type RequestWorkerMaintenanceResponse = (unknown);

export type RequestWorkerMaintenanceError = (HTTPValidationError);

export type UpdateWorkerMaintenanceData = {
    body: MaintenanceRequest;
    path: {
        worker_name: string;
    };
};

export type UpdateWorkerMaintenanceResponse = (unknown);

export type UpdateWorkerMaintenanceError = (HTTPValidationError);

export type ExitWorkerMaintenanceData = {
    path: {
        worker_name: string;
    };
};

export type ExitWorkerMaintenanceResponse = (unknown);

export type ExitWorkerMaintenanceError = (HTTPValidationError);

export type RequestWorkerShutdownData = {
    path: {
        worker_name: string;
    };
};

export type RequestWorkerShutdownResponse = (unknown);

export type RequestWorkerShutdownError = (HTTPValidationError);

export type DeleteWorkerData = {
    path: {
        worker_name: string;
    };
};

export type DeleteWorkerResponse = (unknown);

export type DeleteWorkerError = (HTTPValidationError);

export type AddWorkerQueueData = {
    path: {
        queue_name: string;
        worker_name: string;
    };
};

export type AddWorkerQueueResponse = (unknown);

export type AddWorkerQueueError = (HTTPValidationError);

export type RemoveWorkerQueueData = {
    path: {
        queue_name: string;
        worker_name: string;
    };
};

export type RemoveWorkerQueueResponse = (unknown);

export type RemoveWorkerQueueError = (HTTPValidationError);